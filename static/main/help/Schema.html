<html>
<head>
<TITLE>JBEI EDD Database Schema</TITLE>
<style type="text/css">
<!--
@import "../Common.css";
-->

p.schema {
	white-space:pre-wrap;
	font-family: "Lucida Console", Monaco, monospace;
	line-height:120%;
	padding:0em 0.5em 0.4em 0.5em;
	color:#800;
	font-size:12px;
}

div.schemaNote {
	font-size:12px;
	margin:0 1.2em 0 1.2em;
	padding:0px 0px;
	border-radius:6px;
	background-color:#EEE;
}

div.schemaNote ul {
	margin-top:0em;
	margin-bottom:0em;
	padding-top:0em;
	padding-bottom:0.5em;
}

div.c {
	margin:1em;
	border:none;
	text-align:center;
}

div.if {
	display:inline-block;
	box-shadow: inset 0 0 20px 20px #FFF;
	-webkit-box-shadow: inset 0 0 20px 20px #FFF;
	-moz-box-shadow: inset 0 0 20px 20px #FFF;
	border:1px solid #CCC;
	background:none;
	z-index: 10;
}

div.if img {
	position:relative;
	padding:0;
	border: 0px;
	border-radius:35px;
	z-index: -1;
}

span.denormalized {
	font-weight:normal;
	color:#777;
}

</style>

</head>
<body>

<h2>JBEI EDD Database Schema</h2>

<p>The following diagram is a visual representation of the EDD database schema, where each shaded box is a table, and each dotted line is an association between fields in two given tables.  The gray boxes are tables that use multiple indexes to create a many-to-many association between the records in the tables around them.</p>

<p>To simplify the diagram, the denormalized data associations have been left out.  For example, Studies is linked to Lines via a "study_id" field, and Lines is linked to Assays via a "line_id" field, and both these links are visible as lines in the diagram, but Studies is also linked directly to Assays with a denormalized "study_id" field in the Assays table.  That link is redundant, however:  Since an Assay must belong to one Line only, and a Line must belong to one Study only, the Study that the Assay is linked with is implicit in that hierarchy.  (Why include denormalized data?  To make certain operations faster.)</p>

<p>There are only a handful of denormalized fields in the schema.  For details, you can check out the table declarations themselves.</p>

<div class="c"><img src="Schema_Diagram-Full.png" /></div>

<p>Let's take a closer look at the interconnections between the six tables that make up the core of the EDD's data.  First up, is the all-important Accounts table.</p>

<div class="c"><div class="if"><img src="Schema_Diagram-Accounts.png" /></div></div>

<p>This table has one-to-many relationships with almost all of the other structures in the EDD.  Most of these relationships establish "ownership" of the various records, and with additional relationships for "modified by", and a few miscellaneous associations, like "experimenter" for Lines, Assays, and Measurements.</p> 

<div class="c"><div class="if"><img src="Schema_Diagram-Studies.png" /></div></div>

<p>Then there's the Studies table, the largest identifying container unit for organizing client data.</p>

<p>Each Study can have a unique collection of comments, a unique collection of metadata values, and a unique collection of Lines related to it, and only it.  (These are called "identifying" relationships, because each comment, metadata value, or Line <i>must</i> be related with a Study to be valid.)</p>

<p>In addition, Studies can be optionally related to one or more folders, and or more file attachments.  (File attachments can also be associated with Protocols, so the relationship they can have to Studies is not "identifying".)</p>

<div class="c"><div class="if"><img src="Schema_Diagram-Lines.png" /></div></div>

<p>One step down the hierarchy, we find Lines.  To be valid, a Line must be related to one Study, and one account holder.  It can also have a one-to-many identifying relationship with any number of Assays, and a many-to-many relationship with any number of carbon sources via the intermediating "carbon_sources_to_lines" table.</p>

<p>Putting it another way, Studies contain Lines, which in turn contain Assays.</p>

<div class="c"><div class="if"><img src="Schema_Diagram-Assays.png" /></div></div>

<p>For an Assay to be valid, it must be associated with exactly one user account (the Assay's creator), one Line, and one Protocol.</p>

<div class="c"><div class="if"><img src="Schema_Diagram-Measurements.png" /></div></div>

<p>Each Assay contains a collection of Measurements.  Each Measurement is associated with a single Measurement Type and a single owner.</p>

<div class="c"><div class="if"><img src="Schema_Diagram-Data.png" /></div></div>

<p>Each Measurement contains a collection of Measurement Data records, each specifying a timestamp and a value (which can be NULL).</p>

<h3>Full schema as table declarations</h3>

<p>These are listed in the order they need to be created to properly construct the dependencies.  (The actual SQL script file that can be fed into the console just creates the dependencies in one big run after declaring all the tables.)  Denormalized fields are colored gray.</p>

<p class="schema">
CREATE TABLE site_preferences (
  adding_is_enabled BOOLEAN DEFAULT TRUE,
  adding_disabled_notes character varying(256) DEFAULT ''
);
</p>

<div class="schemaNote"><p>"adding_is_enabled" is a flag, that if set by an administrator, freezes all adding of new Study data to the system.  "adding_disabled_notes" is displayed in a banner at the top of the page when the flag is set.</p></div>

<p class="schema">
CREATE TABLE accounts (
    id SERIAL,
    creation_time TIMESTAMP without time zone DEFAULT '27 December 1831',
    firstname character varying(50) NOT NULL,
    lastname character varying(50) NOT NULL,
    initials character varying(10) NOT NULL,
    description text DEFAULT '',
    email character varying(100) NOT NULL,
    institution character varying(255) DEFAULT '',
    password character varying(40) NOT NULL,
    editor BOOLEAN DEFAULT FALSE,
    superuser BOOLEAN DEFAULT FALSE,
    disabled BOOLEAN DEFAULT FALSE,
    lastlogin_time TIMESTAMP without time zone DEFAULT '27 December 1831',
    modification_time TIMESTAMP without time zone DEFAULT '27 December 1831',
        CONSTRAINT accounts_pkey PRIMARY KEY (id),
        CONSTRAINT accounts_email_key UNIQUE (email)
);
</p>

<div class="schemaNote"><p>The default value for timestamps in the EDD is not NULL, but instead "27 December 1831", the sail date of the HMS Beagle.  For the LULZ.  Also because if we guarantee that it's not NULL, we can write slightly simpler code.  But mostly for the LULZ.</p>

<p>"email" is declared as NOT NULL because it is required:  Users log in by entering their email address and their password.</p></div>

<p class="schema">
CREATE TABLE account_preferences (
    account_id BIGINT NOT NULL,
    misc_preferences text,
        CONSTRAINT account_preferences_account_id_key UNIQUE (account_id),
        CONSTRAINT fk_account_preferences_account_id_key FOREIGN KEY (account_id)
            REFERENCES accounts (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION
);


CREATE TABLE account_column_preferences (
    account_id BIGINT NOT NULL,
    page_name text,
    columns_string text,
        CONSTRAINT account_column_preferences_account_id_key UNIQUE (account_id, page_name),
        CONSTRAINT fk_account_column_preferences_account_id_key FOREIGN KEY (account_id)
            REFERENCES accounts (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION
);
</p>

<div class="schemaNote"><p>Users can hide and show columns in the various tables spread around the site.  This table is used to retain their selections between visits.</p></div>

<p class="schema">
CREATE TABLE access_groups (
    id SERIAL,
    creation_time TIMESTAMP without time zone DEFAULT '27 December 1831',
    shortname character varying(50) NOT NULL,
    description text NOT NULL,
    email character varying(100) NOT NULL,
    disabled BOOLEAN DEFAULT FALSE,
    modification_time TIMESTAMP without time zone DEFAULT '27 December 1831',
        CONSTRAINT access_groups_pkey PRIMARY KEY (id),
        CONSTRAINT access_groups_shortname_key UNIQUE (shortname)
);
</p>

<div class="schemaNote"><p>Presently these groups can be edited and linked with users, but they are not used for filtering, so they do not have any effect on security.</p></div>

<p class="schema">
CREATE TABLE accounts_to_access_groups (
    account_id BIGINT NOT NULL,
    access_group_id BIGINT NOT NULL,
        CONSTRAINT accounts_to_access_groups_key UNIQUE (account_id, access_group_id),
        CONSTRAINT fk_accounts_to_access_groups_account_id FOREIGN KEY (account_id)
            REFERENCES accounts (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
        CONSTRAINT fk_accounts_to_access_groups_access_group_id FOREIGN KEY (access_group_id)
            REFERENCES access_groups (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION
);


CREATE TABLE measurement_units (
    id SERIAL,
    unit_name text,
    alternate_unit_names text DEFAULT '',
    display BOOLEAN DEFAULT TRUE,
        CONSTRAINT measurement_units_pkey PRIMARY KEY (id),
        CONSTRAINT measurement_units_unit_name_key UNIQUE (unit_name)
);
</p>

<div class="schemaNote"><p>"alternate_unit_names" can be listed in any format, since the EDD performs a substring search on the whole field without attempting to parse it or break it up.</p></div>

<p class="schema">
CREATE TABLE measurement_type_keywords (
    id SERIAL,
    keyword text,
    modified_by BIGINT DEFAULT 0,
        CONSTRAINT measurement_type_keywords_pkey PRIMARY KEY (id),
        CONSTRAINT measurement_type_keywords_keyword_key UNIQUE (keyword)
);


CREATE TABLE measurement_types_to_keywords (
    measurement_type_id BIGINT NOT NULL,
    keyword_id BIGINT NOT NULL,
        CONSTRAINT measurement_types_to_keywords_key UNIQUE (keyword_id, measurement_type_id),
        CONSTRAINT fk_measurement_types_to_keywords_keyword_id FOREIGN KEY (keyword_id)
            REFERENCES measurement_type_keywords (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
        CONSTRAINT fk_measurement_types_to_keywords_measurement_type_id FOREIGN KEY (measurement_type_id)
            REFERENCES measurement_types (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION
);


CREATE TABLE measurement_types (
    id SERIAL,
    type_name text,
    short_name text,
    molecular_formula text,
    charge text,
    molar_mass double precision,
    carbon_count int,
    display_format BIGINT NOT NULL DEFAULT 0,
    measurement_group_id BIGINT NOT NULL,
        CONSTRAINT measurement_types_pkey PRIMARY KEY (id),
        CONSTRAINT measurement_types_type_name_key UNIQUE (type_name),
        CONSTRAINT measurement_types_short_name_key UNIQUE (short_name)
);
</p>

<div class="schemaNote">
<p>Both the "type_name" and the "short_name" must be unique across records.  Some of the UI of the EDD, and some of the operations within the EDD (SBML generation for example) rely on this.</p>

<p>"molecular_formula" is a simple string, like "H2SO4".  The EDD attempts to derive "carbon_count" by parsing the formula, if present during creation or editing of the record.  "carbon_count" is a separate field so that users can declare a carbon count for a measurement even if they're not able to declare an exact formula.</p>
</div>

<p class="schema">
CREATE TABLE alternate_measurement_type_names (
    alternate_name text,
    manual_pairing_count BIGINT NOT NULL DEFAULT 0,
    measurement_type_id BIGINT NOT NULL,
        CONSTRAINT alternate_measurement_type_names_key UNIQUE (alternate_name, measurement_type_id),
        CONSTRAINT fk_alternate_measurement_type_names_key_measurement_type_id FOREIGN KEY (measurement_type_id)
            REFERENCES measurement_types (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION
);
</p>

<div class="schemaNote"><p>"manual_pairing_count" is the number of times a user has manually matched the name string
with the measurement type in an import.  This acts as a measure of the popularity of the alternate name,
and is used as a ranking device when assigning alternate names to measurement types during the generation of
a consolidated list.</p></div>

<p class="schema">
CREATE TABLE metadata_groups (
    id SERIAL,
    group_name character varying(250),
    modification_time TIMESTAMP without time zone DEFAULT '27 December 1831',
    modified_by BIGINT DEFAULT 0,
        CONSTRAINT metadata_groups_pkey PRIMARY KEY (id),
        CONSTRAINT metadata_groups_key UNIQUE (group_name)
);


CREATE TABLE metadata_types (
    id SERIAL,
    metadata_group_id BIGINT NOT NULL,
    type_name character varying(250),
    input_size int default 6,
    prefix character varying(250),
    postfix character varying(250),
    default_value character varying(250),
    line_level BOOLEAN DEFAULT TRUE,
    protocol_level BOOLEAN DEFAULT FALSE,
    modification_time TIMESTAMP without time zone DEFAULT '27 December 1831',
    modified_by BIGINT DEFAULT 0,
        CONSTRAINT metadata_types_pkey PRIMARY KEY (id),
        CONSTRAINT metadata_types_type_name_key UNIQUE (type_name),
        CONSTRAINT fk_metadata_types_metadata_group_id FOREIGN KEY (metadata_group_id)
            REFERENCES metadata_groups (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION
);</p>

<div class="schemaNote"><p>"input_size" is not a limit on the size of the metadata value, but is instead just a hint for how large to draw the input field when offering it for user data entry.</p>

<p>The "line_level" and "protocol_level" booleans declare whether the metadata type is meant to apply to entire Lines, or to Assays of specific Protocols (elucidated in table "protocols_to_metadata_types").  It's more of a guide than a fast rule:  It is still permissible to declare a metadata type in either context.</p></div>

<p class="schema">
CREATE TABLE protocols (
    id SERIAL,
    protocol_name text,
    variant_of_id BIGINT DEFAULT 0,
    default_units BIGINT DEFAULT 0,
    created_by BIGINT NOT NULL,
    owned_by BIGINT DEFAULT 0,
    modification_time TIMESTAMP without time zone DEFAULT '27 December 1831',
    description text DEFAULT '',
    disabled BOOLEAN DEFAULT FALSE,
        CONSTRAINT protocols_pkey PRIMARY KEY (id),
        CONSTRAINT protocols_protocol_name_key UNIQUE (protocol_name),
        CONSTRAINT fk_protocols_default_units FOREIGN KEY (default_units)
            REFERENCES measurement_units (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION
);


CREATE TABLE protocols_to_measurement_types (
    protocol_id BIGINT NOT NULL,
    measurement_type_id BIGINT NOT NULL,
        CONSTRAINT protocols_to_measurement_types_key UNIQUE (protocol_id, measurement_type_id),
        CONSTRAINT fk_protocols_to__measurement_types_protocol_id FOREIGN KEY (protocol_id)
            REFERENCES protocols (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
        CONSTRAINT fk_protocols_to__measurement_types_measurement_type_id FOREIGN KEY (measurement_type_id)
            REFERENCES measurement_types (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION
);


CREATE TABLE protocols_to_metadata_types (
    protocol_id BIGINT NOT NULL,
    metadata_type_id BIGINT NOT NULL,
        CONSTRAINT protocols_to_metadata_types_key UNIQUE (protocol_id, metadata_type_id),
        CONSTRAINT fk_protocols_to_metadata_types_protocol_id FOREIGN KEY (protocol_id)
            REFERENCES protocols (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
        CONSTRAINT fk_protocols_to_metadata_types_metadata_type_id FOREIGN KEY (metadata_type_id)
            REFERENCES metadata_types (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION
);


CREATE TABLE carbon_sources (
    id SERIAL,
    carbon_source text,
    labeling text,
    volume BIGINT DEFAULT 0,
    additional_info text DEFAULT '',
    creation_time TIMESTAMP without time zone DEFAULT '27 December 1831',
    created_by BIGINT NOT NULL,
    modified_by BIGINT DEFAULT 0,
    modification_time TIMESTAMP without time zone DEFAULT '27 December 1831',
    disabled BOOLEAN DEFAULT FALSE,
        CONSTRAINT feeds_pkey PRIMARY KEY (id),
        CONSTRAINT fk_feeds_created_by FOREIGN KEY (created_by)
            REFERENCES accounts (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION
);


CREATE TABLE strains (
    id SERIAL,
    strain_name text,
    long_name text,
    registry_url text,
    creation_time TIMESTAMP without time zone DEFAULT '27 December 1831',
    created_by BIGINT NOT NULL,
    modified_by BIGINT DEFAULT 0,
    modification_time TIMESTAMP without time zone DEFAULT '27 December 1831',
    disabled BOOLEAN DEFAULT FALSE,
        CONSTRAINT strains_pkey PRIMARY KEY (id),
        CONSTRAINT fk_strains_created_by FOREIGN KEY (created_by)
            REFERENCES accounts (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION
);


CREATE TABLE studies (
    id SERIAL,
    study_name character varying(250),
    additional_info text,
    creation_time TIMESTAMP without time zone DEFAULT '27 December 1831',
    created_by BIGINT NOT NULL,
    contact text DEFAULT '',
    modification_time TIMESTAMP without time zone DEFAULT '27 December 1831',
    modified_by BIGINT DEFAULT 0,
    disabled BOOLEAN DEFAULT FALSE,
        CONSTRAINT studies_pkey PRIMARY KEY (id),
        CONSTRAINT fk_studies_created_by FOREIGN KEY (created_by)
            REFERENCES accounts (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION
);


CREATE TABLE lines (
    id SERIAL,
    study_id BIGINT NOT NULL,
    line_name character varying(250),
    strain_id BIGINT DEFAULT 0,
    media_type text DEFAULT '--',
    contact text DEFAULT '',
    experimenter BIGINT DEFAULT 0,
    is_control BOOLEAN DEFAULT FALSE,
    modification_time TIMESTAMP without time zone DEFAULT '27 December 1831',
    modified_by BIGINT DEFAULT 0,
    creation_time TIMESTAMP without time zone DEFAULT '27 December 1831',
    created_by BIGINT NOT NULL,
    disabled BOOLEAN DEFAULT FALSE,
        CONSTRAINT lines_pkey PRIMARY KEY (id),
        CONSTRAINT fk_lines_created_by FOREIGN KEY (created_by)
            REFERENCES accounts (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
        CONSTRAINT fk_lines_study_id FOREIGN KEY (study_id)
            REFERENCES studies (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION
);


CREATE TABLE carbon_sources_to_lines (
    <span class="denormalized">study_id BIGINT NOT NULL,</span>
    line_id BIGINT NOT NULL,
    carbon_source_id BIGINT NOT NULL,
        CONSTRAINT carbon_sources_to_lines_key UNIQUE (line_id, carbon_source_id),
        CONSTRAINT fk_carbon_sources_to_lines_line_id FOREIGN KEY (line_id)
            REFERENCES lines (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
        CONSTRAINT fk_carbon_sources_to_lines_carbon_source_id FOREIGN KEY (carbon_source_id)
            REFERENCES carbon_sources (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
        CONSTRAINT fk_carbon_sources_to_lines_study_id FOREIGN KEY (study_id)
            REFERENCES studies (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION
);
</p>

<div class="schemaNote"><p>A Line can have multiple carbon sources linked to it.  Uniqueness is only enforced over pairs of "line_id" and "carbon_source_id".</p></div>

<p class="schema">
CREATE TABLE assays (
    id SERIAL,
    assay_name character varying(250),
    description text,
    <span class="denormalized">study_id BIGINT NOT NULL,</span>
    line_id BIGINT NOT NULL,
    protocol_id BIGINT NOT NULL,
    creation_time TIMESTAMP without time zone DEFAULT '27 December 1831',
    created_by BIGINT NOT NULL,
    experimenter BIGINT DEFAULT 0,
    modification_time TIMESTAMP without time zone DEFAULT '27 December 1831',
    modified_by BIGINT DEFAULT 0,
    disabled BOOLEAN DEFAULT FALSE,
        CONSTRAINT assays_pkey PRIMARY KEY (id),
        CONSTRAINT fk_assay_study_id FOREIGN KEY (study_id)
            REFERENCES studies (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
        CONSTRAINT fk_assays_line_id FOREIGN KEY (line_id)
            REFERENCES lines (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
        CONSTRAINT fk_assays_protocol_id FOREIGN KEY (protocol_id)
            REFERENCES protocols (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
        CONSTRAINT fk_assays_created_by_id FOREIGN KEY (created_by)
            REFERENCES accounts (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION
);


CREATE TABLE assay_measurements (
    id SERIAL,
    <span class="denormalized">study_id BIGINT NOT NULL,</span>
    <span class="denormalized">line_id BIGINT NOT NULL,</span>
    assay_id BIGINT NOT NULL,
    <span class="denormalized">protocol_id BIGINT NOT NULL,</span>
    measurement_type_compartment BIGINT NOT NULL DEFAULT 0,
    measurement_type_id BIGINT NOT NULL,
    measurement_type_format BIGINT NOT NULL DEFAULT 0,
    x_axis_units BIGINT DEFAULT 0,
    y_axis_units BIGINT DEFAULT 0,
    creation_time TIMESTAMP without time zone DEFAULT '27 December 1831',
    created_by BIGINT NOT NULL,
    experimenter BIGINT DEFAULT 0,
    modification_time TIMESTAMP without time zone DEFAULT '27 December 1831',
    modified_by BIGINT DEFAULT 0,
    disabled BOOLEAN DEFAULT FALSE,
        CONSTRAINT assay_measurements_pkey PRIMARY KEY (id),
        CONSTRAINT assay_measurements_one_kind UNIQUE (assay_id, measurement_type_compartment, measurement_type_id, measurement_type_format),
        CONSTRAINT fk_assay_measurements_study_id FOREIGN KEY (study_id)
            REFERENCES studies (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
        CONSTRAINT fk_assay_measurements_line_id FOREIGN KEY (line_id)
            REFERENCES lines (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
        CONSTRAINT fk_assay_measurements_assay_id FOREIGN KEY (assay_id)
            REFERENCES assays (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
        CONSTRAINT fk_assay_measurements_protocol_id FOREIGN KEY (protocol_id)
            REFERENCES protocols (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
        CONSTRAINT fk_assays_measurements_measurement_type_id FOREIGN KEY (measurement_type_id)
            REFERENCES measurement_types (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
        CONSTRAINT fk_assays_created_by_id FOREIGN KEY (created_by)
            REFERENCES accounts (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION
);
</p>

<div class="schemaNote"><p>Pairs of "assay_id" and "measurement_type_id" are enforced as unique, so that a given Assay can contain only one run of data per Measurement type.</p>

<p>"measurement_type_compartment" is enumerated as follows:</p>

<ul>
	<li>0 = none</li>
	<li>1 = intracellular/cytosine</li>
	<li>2 = extracellular</li>
</ul>
</div>

<p class="schema">
CREATE TABLE assay_measurement_data (
    id SERIAL,
    <span class="denormalized">study_id BIGINT NOT NULL,</span>
    <span class="denormalized">line_id BIGINT NOT NULL,</span>
    <span class="denormalized">assay_id BIGINT NOT NULL,</span>
    <span class="denormalized">protocol_id BIGINT NOT NULL,</span>
    measurement_id BIGINT NOT NULL,
    measurement_type_id BIGINT NOT NULL,
    x double precision NOT NULL,
    y double precision,
    yvector character varying(250),
    modification_time TIMESTAMP without time zone DEFAULT '27 December 1831',
    modified_by BIGINT DEFAULT 0,
        CONSTRAINT assay_measurement_data_pkey PRIMARY KEY (id),
        CONSTRAINT assay_measurement_data_one_pair UNIQUE (measurement_id, x),
        CONSTRAINT fk_assay_measurement_data_study_id FOREIGN KEY (study_id)
            REFERENCES studies (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
        CONSTRAINT fk_assay_measurement_data_line_id FOREIGN KEY (line_id)
            REFERENCES lines (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
        CONSTRAINT fk_assay_measurement_data_assay_id FOREIGN KEY (assay_id)
            REFERENCES assays (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
        CONSTRAINT fk_assay_measurement_data_measurement_id FOREIGN KEY (measurement_id)
            REFERENCES assay_measurements (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
        CONSTRAINT fk_assay_measurement_data_protocol_id FOREIGN KEY (protocol_id)
            REFERENCES protocols (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
        CONSTRAINT fk_assays_measurement_data_measurement_type_id FOREIGN KEY (measurement_type_id)
            REFERENCES measurement_types (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION
);
</p>

<div class="schemaNote">
<p>
Pairs of "measurement_id" and "x" are enforced as unique, so each measurement only has one value per timestamp.
</p>

<p>"yvector" is a comma-delimited set of floating point values of arbitrary length, and is used to contain carbon ratio data.</p>

<p>How does this make sense from a database design perspective?  Consider the following.</p>

<ul>
	<li>We always need to retrieve the full set of values, and with this approach we can do so by fetching one record.</li>
	<li>We will never need to update an individual value in the middle of a sequence.</li>
	<li>We get the ordering of the comma-delimited values "for free".  No need for a separate "order" column that we need to sort by.</li>
	<li>Since we're storing carbon ratios, we know our sequences of numbers will never have large gaps that would make this inefficient; in fact we know that our sequences will have NO gaps, and will generally consist of three or four numbers.</li>
	<li>Consider the average size of a database record in memory, versus the average size of a double-precision floating-point value expressed in ASCII.  Consider that we will not need an indexing tree for an "order" column, nor for an additional unique identifier on top of the ID that groups a given set of values into a sequence.</li>
</ul>

<p>But wait, you say, doesn't this also create additional overhead parsing the strings into floating point values?  Well, consider that we are likely going to be dumping these strings <i>directly</i> into a JSON object, in which case we will not be parsing them on the back end <i>at all</i>.</p>

</div>

<p class="schema">
CREATE TABLE attachments (
    id SERIAL,
    study_id BIGINT DEFAULT 0,
    line_id BIGINT DEFAULT 0,
    assay_id BIGINT DEFAULT 0,
    protocol_id BIGINT DEFAULT 0,
    metabolic_map_id BIGINT DEFAULT 0,
    description text NOT NULL,
    created_by BIGINT NOT NULL,
    mime_type text,
    filename character varying(255) NOT NULL,
    file_size BIGINT NOT NULL,
    file_data bytea NOT NULL,
    creation_time TIMESTAMP without time zone DEFAULT '27 December 1831',
        CONSTRAINT attachments_pkey PRIMARY KEY (id),
        CONSTRAINT fk_attachments_created_by FOREIGN KEY (created_by)
            REFERENCES accounts (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION
);


CREATE TABLE metabolic_maps (
    id SERIAL,
    attachment_id BIGINT NOT NULL,
    biomass_exchange_name text NOT NULL,
        CONSTRAINT sbml_models_pkey PRIMARY KEY (id),
        CONSTRAINT fk_sbml_models_attachment_id FOREIGN KEY (attachment_id)
            REFERENCES attachments (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION
);
</p>

<div class="schemaNote"><p>File attachments can be associated with a Protocol or a Study or have a one-to-one connection to an SBML model record.</p></div>

<p class="schema">
CREATE TABLE comments (
    id SERIAL,
    study_id BIGINT NOT NULL,
    line_id BIGINT DEFAULT 0,
    assay_id BIGINT DEFAULT 0,
    measurement_id BIGINT DEFAULT 0,
    measurement_data_x double precision DEFAULT 0,
    body text NOT NULL,
    creation_time TIMESTAMP without time zone DEFAULT '27 December 1831',
    created_by BIGINT NOT NULL,
        CONSTRAINT comments_pkey PRIMARY KEY (id),
        CONSTRAINT fk_comments_study_id FOREIGN KEY (study_id)
            REFERENCES studies (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
        CONSTRAINT fk_comments_created_by FOREIGN KEY (created_by)
            REFERENCES accounts (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION
);
</p>

<div class="schemaNote"><p>Each comment is always linked to a study.  Linking a comment to an individual line or sample set in an study is optional.
</p></div>

<p class="schema">
CREATE TABLE folders (
    id SERIAL,
    name character varying(255) NOT NULL,
    description character varying(1023),
    created_by BIGINT NOT NULL,
    parent_id BIGINT,
        CONSTRAINT folders_pkey PRIMARY KEY (id),
        CONSTRAINT fk_folders_created_by FOREIGN KEY (created_by)
            REFERENCES accounts (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION
);
</p>

<div class="schemaNote"><p>Folders are an optional hierarchal organization tool for experiments.  Folders can be nested within each other using 'parent_id'.  Better make sure there's some logic to avoid infinite loops, eh?
Note: Not being used for now (not in database).  Rename to 'collections'?
</p></div>

<p class="schema">
CREATE TABLE folders_to_studies (
    folder_id BIGINT NOT NULL,
    study_id BIGINT NOT NULL,
        CONSTRAINT folders_to_studies_key UNIQUE (folder_id, study_id),
        CONSTRAINT fk_folders_to_studies_folder_id FOREIGN KEY (folder_id)
            REFERENCES folders (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
        CONSTRAINT fk_folders_to_studies_study_id FOREIGN KEY (study_id)
            REFERENCES studies (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION
);
</p>

<div class="schemaNote"><p>We are allowing experiments to reside in several folders at once, since each user may have their own organizational needs for folders, and not all folders will be visible to all users, and experiments themselves have their own visibility permissions anyway.</p>

<p>Note that this is disabled.  We are currently grouping experiments just by access group and metadata.  This will probably change.</p></div>

<p class="schema">
CREATE TABLE metadata_values (
    study_id BIGINT NOT NULL,
    line_id BIGINT DEFAULT 0,
    assay_id BIGINT DEFAULT 0,
    metadata_type_id BIGINT NOT NULL,
    data_value character varying(250),
    modification_time TIMESTAMP without time zone DEFAULT '27 December 1831',
    modified_by BIGINT DEFAULT 0,
        CONSTRAINT metadata_values_key UNIQUE (study_id, line_id, assay_id, metadata_type_id),
        CONSTRAINT fk_metadata_values_study_id FOREIGN KEY (study_id)
            REFERENCES studies (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION,
        CONSTRAINT fk_metadata_values_metadata_type FOREIGN KEY (metadata_type_id)
            REFERENCES metadata_types (id) MATCH SIMPLE ON UPDATE NO ACTION ON DELETE NO ACTION
);
</p>

<div class="schemaNote"><p>There can only be one instance of (and thereby only one value specified for) a given combination of Study, Line, Assay, and metadata type.  We are leveraging that as a constraint for uniqueness in this table.</p>

<p>We are also allowing "line_id" and "assay_id" to be null, such that we can have metadata that only applies to a Study as a whole (and all Lines in it), or that applies to a Study and only one of its Lines as a whole (and all Assays in that Line), or to one Study and one of its Lines and only one of the Line's assays.</p>

<p>For example, if "assay_id" in a given record is NULL, then the metadata value is said to apply to ALL Assays under that Line and Study ... unless that value is overridden by another one specifically identifying a particular Assay in "assay_id".</p></div>

</body>
</html>
