// File last modified on: Wed Dec 21 2016 14:53:35  
/// <reference path="../typings/underscore/underscore.d.ts"/>;
/// <reference path="../typings/d3/d3.d.ts"/>;
var GraphHelperMethods;
GraphHelperMethods = {
    nextColor: null,
    labels: [],
    remakeGraphCalls: 0,
    colors: {
        0: '#0E6FA4',
        1: '#51BFD8',
        2: '#2a2056',
        3: '#FCA456',
        4: '#2b7b3d',
        5: '#97d37d',
        6: '#CF5030',
        7: '#FFB6C1',
        8: '#6f2f8c',
        9: '#b97dd3',
        10: '#7e0404',
        11: '#765667',
        12: '#F279BA',
        13: '#993f6c',
        14: '#919191',
        15: '#BFBFBD',
        16: '#ecda3a',
        17: '#b2b200',
        18: '#006E7E',
        19: '#b2f2fb',
        20: '#0715CD',
        21: '#e8c2f3',
        22: '#7a5230' //brown
    },
    /**
     *  This function takes an array of arrays of arrays and flattens it into one array of arrays.
    **/
    concatAssays: function (assays) {
        return [].concat.apply([], assays);
    },
    /**
     *  This function takes a unit id and unit type json and returns the unit name
    **/
    unitName: function (unitId, unitTypes) {
        return unitTypes[unitId].name;
    },
    /**
     *  This function takes a measurement id and measurement type json and returns the
     *  measurement name
    **/
    measurementName: function (measurementId, measurementTypes) {
        return measurementTypes[measurementId].name;
    },
    /**
     *  This function takes a selector element and returns an svg element
    **/
    createSvg: function (selector) {
        var svg = d3.select(selector).append("svg")
            .attr("preserveAspectRatio", "xMinYMin meet")
            .attr("viewBox", "-55 -30 960 300")
            .classed("svg-content", true);
        return svg;
    },
    /**
     *  This function takes in EDDdata, a singleAssay line entry, and measurement names and
     *  transforms it into the following schema:
     *    [{label: "dt9304, x: 1, y: 2.5, x_unit: "n/a", y_unit: "cmol",  name: "i'm a protein
     *    name"},
     *    {label: "dt3903, x: 1, y: 23.5, x_unit: "n/a", y_unit: "cmol",  name: "i'm another protein
     *    name"}
     *    ...
     *    ]
    **/
    transformSingleLineItem: function (dataObj) {
        // unit types
        var unitTypes = dataObj['data'].UnitTypes;
        // measurement types
        var measurementTypes = dataObj['data'].MeasurementTypes;
        // array of x and y values for sorting
        var xAndYValues = [];
        //data for one line entry
        var singleDataValues = dataObj['measure'].values;
        _.each(singleDataValues, function (dataValue, index) {
            var dataset = {};
            //can also change to omit data point with null which was done before..
            if (dataValue[0].length == 0) {
                dataValue[0] = ["0"];
            }
            else if (dataValue[1].length == 0) {
                dataValue[1] = ["0"];
            }
            dataset['label'] = 'dt' + dataObj['measure'].assay;
            dataset['x'] = parseFloat(dataValue[0].join());
            dataset['y'] = parseFloat(dataValue[1].join());
            dataset['x_unit'] = GraphHelperMethods.unitName(dataObj['measure'].x_units, unitTypes);
            dataset['y_unit'] = GraphHelperMethods.unitName(dataObj['measure'].y_units, unitTypes);
            dataset['name'] = dataObj['name'];
            dataset['color'] = dataObj['color'];
            dataset['nameid'] = dataObj['names'] + index;
            dataset['lineName'] = dataObj['lineName'];
            dataset['measurement'] = GraphHelperMethods.measurementName(dataObj['measure'].type, measurementTypes);
            dataset['fullName'] = dataObj['lineName'] + ' ' + dataset['measurement'];
            xAndYValues.push(dataset);
        });
        xAndYValues.sort(function (a, b) {
            return a.x - b.x;
        });
        return xAndYValues;
    },
    /**
    * this function is the same as above but more simple as it is for the import section.
   **/
    transformNewLineItem: function (data, singleData) {
        // array of x and y values for sortin
        var xAndYValues = [];
        //data for one line entry
        var singleDataValues = singleData.data;
        var fullName = singleData.label;
        _.each(singleDataValues, function (dataValue) {
            var dataset = {};
            //can also change to omit data point with null which was done before..
            if (dataValue[0] == null) {
                dataValue[0] = ["0"];
            }
            else if (dataValue[1] == null) {
                dataValue[1] = ["0"];
            }
            dataset['newLine'] = true;
            dataset['x'] = dataValue[0];
            dataset['y'] = parseFloat(dataValue[1]);
            dataset['name'] = singleData.name;
            dataset['fullName'] = fullName;
            xAndYValues.push(dataset);
        });
        xAndYValues.sort(function (a, b) {
            return a.x - b.x;
        });
        return xAndYValues;
    },
    /**
     * this function takes in a single line name and study's lines and returns an object of
     * color values with lid keys
     * loosely based on d3 category20 in following link:
     * http://bl.ocks.org/aaizemberg/78bd3dade9593896a59d
    **/
    renderColor: function (lines) {
        //new color object with assay ids and color hex
        var lineColors = {};
        //how many lines
        var lineCount = _.range(Object.keys(lines).length);
        //values of line obj
        var lineValues = _.values(lines);
        //new object with numbers for ids
        var indexLines = {};
        // color obj values
        var colorKeys = _.values(GraphHelperMethods.colors);
        //create index obj with numbers for ids and assay ids as values
        for (var i = 0; i < lineCount.length; i++) {
            indexLines[i] = lineValues[i].id;
        }
        //if there are more than 22 lines, create a bigger color obj
        if (lineValues.length > colorKeys.length) {
            var multiplier = Math.ceil(lineValues.length / colorKeys.length) * 22;
            GraphHelperMethods.colorMaker(GraphHelperMethods.colors, colorKeys, multiplier);
        }
        //combine assay ids as keys with hex colors as values
        _.each(indexLines, function (value, key) {
            lineColors[indexLines[key]] = GraphHelperMethods.colors[key];
        });
        for (var key in lines) {
            lines[key]['color'] = lineColors[key];
        }
        return lineColors;
    },
    /**
     * this function takes in the selected color and returns the color that comes after.
    **/
    colorQueue: function (selectedColor) {
        var reverseColors = GraphHelperMethods.reverseMap(GraphHelperMethods.colors);
        var selectedKey = reverseColors[selectedColor];
        if (parseInt(selectedKey) === 21) {
            selectedKey = -1;
        }
        var nextColor = GraphHelperMethods.colors[parseInt(selectedKey) + 1];
        GraphHelperMethods['nextColor'] = nextColor;
    },
    /**
     * this function takes in an object and value and returns a new object with keys as values
     * and values as keys.
    **/
    reverseMap: function (obj) {
        var reverseMap = {};
        for (var key in obj) {
            if (obj.hasOwnProperty(key)) {
                reverseMap[obj[key]] = key;
            }
        }
        return reverseMap;
    },
    /**
     * this function takes in the color object, colorKeys array, and multiplier to determine how
     * many new colors we need and return and bigger Color object
    **/
    colorMaker: function (colors, colorKeys, multiplier) {
        var i = 23;
        var j = 0;
        while (i < multiplier) {
            colors[i] = colorKeys[j];
            if (j === 21) {
                j = -1;
            }
            j++;
            i++;
        }
        return colors;
    },
    /**
     * This function returns object size
    **/
    objectSize: function (object) {
        var size = 0, key;
        for (key in object) {
            if (object.hasOwnProperty(key))
                size++;
        }
        return size;
    },
    /**
     *  This function takes in the unit type for each array and returns the text to display on
     *  the axis
    **/
    createXAxis: function (graphSet, x, svg, type) {
        if (type === 'x') {
            type = "Time";
        }
        else if (type === 'measurement') {
            type = "Measurement";
        }
        else if (type === "name") {
            type = "Line";
        }
        else {
            type = 'Hours';
        }
        var xAxis = graphSet.x_axis(x);
        if (graphSet.x_unit == undefined) {
            graphSet.x_unit = 'n/a';
        }
        svg.append("g")
            .attr("class", "x axis")
            .style("font-size", "12px")
            .attr("transform", "translate(0," + graphSet.height + ")")
            .call(xAxis)
            .append('text')
            .attr("y", 40)
            .attr("x", graphSet.width / 2)
            .style("text-anchor", "middle")
            .text(type);
        //Draw the x Grid lines
        svg.append("g")
            .attr("class", "grid")
            .attr("transform", "translate(0," + graphSet.height + ")")
            .call(xAxis
            .tickSize(-graphSet.height, 0)
            .tickFormat(""));
    },
    /**
     *  This function creates the left y axis svg object
    **/
    createLeftYAxis: function (graphSet, label, y, svg) {
        var yAxis = d3.svg.axis().scale(y)
            .orient("left").ticks(5).tickFormat(d3.format(".2s"));
        if (label === 'undefined') {
            label = 'n/a';
        }
        svg.append("g")
            .attr("class", "y axis")
            .style("font-size", "12px")
            .call(yAxis)
            .append("text")
            .attr('class', 'axis-text')
            .attr("transform", "rotate(-90)")
            .attr("y", -55)
            .attr("x", 0 - (graphSet.height / 2))
            .attr("dy", "1em")
            .style("text-anchor", "middle")
            .text(label);
        // Draw the y Grid lines
        svg.append("g")
            .attr("class", "grid")
            .call(yAxis
            .tickSize(-graphSet.width, 0)
            .tickFormat(""));
    },
    /**
     *  This function creates the right y axis svg object
    **/
    createRightYAxis: function (label, y, svg, spacing) {
        var yAxis = d3.svg.axis().scale(y)
            .orient("right").ticks(5).tickFormat(d3.format(".2s"));
        svg.append("g")
            .attr("class", "y axis")
            .attr("transform", "translate(" + spacing + " ,0)")
            .style("font-size", "12px")
            .style("fill", "black")
            .call(yAxis)
            .append('text')
            .attr("transform", "rotate(-90)")
            .attr('class', 'text')
            .attr('x', -110)
            .attr("dy", ".32em")
            .attr('y', 43)
            .style('text-anchor', 'middle')
            .text(label);
    },
    /**
     *  This function creates the y axis tick marks for grid
    **/
    make_right_y_axis: function (y) {
        return d3.svg.axis()
            .scale(y)
            .orient("left");
        //add ticks here!
    },
    /**
     *  This function creates the x axis tick marks for grid
    **/
    make_x_axis: function (x) {
        return d3.svg.axis()
            .scale(x)
            .orient("bottom");
    }
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiR3JhcGhIZWxwZXJNZXRob2RzLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiR3JhcGhIZWxwZXJNZXRob2RzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLG9EQUFvRDtBQUNwRCw4REFBOEQ7QUFDOUQsOENBQThDO0FBRTlDLElBQUksa0JBQXNCLENBQUM7QUFFM0Isa0JBQWtCLEdBQUc7SUFFakIsU0FBUyxFQUFFLElBQUk7SUFDZixNQUFNLEVBQUUsRUFBRTtJQUNWLGdCQUFnQixFQUFFLENBQUM7SUFDbkIsTUFBTSxFQUFFO1FBQ0EsQ0FBQyxFQUFFLFNBQVM7UUFDWixDQUFDLEVBQUUsU0FBUztRQUNaLENBQUMsRUFBRSxTQUFTO1FBQ1osQ0FBQyxFQUFFLFNBQVM7UUFDWixDQUFDLEVBQUUsU0FBUztRQUNaLENBQUMsRUFBRSxTQUFTO1FBQ1osQ0FBQyxFQUFFLFNBQVM7UUFDWixDQUFDLEVBQUUsU0FBUztRQUNaLENBQUMsRUFBRSxTQUFTO1FBQ1osQ0FBQyxFQUFFLFNBQVM7UUFDWixFQUFFLEVBQUUsU0FBUztRQUNiLEVBQUUsRUFBRSxTQUFTO1FBQ2IsRUFBRSxFQUFFLFNBQVM7UUFDYixFQUFFLEVBQUUsU0FBUztRQUNiLEVBQUUsRUFBRSxTQUFTO1FBQ2IsRUFBRSxFQUFFLFNBQVM7UUFDYixFQUFFLEVBQUUsU0FBUztRQUNiLEVBQUUsRUFBRSxTQUFTO1FBQ2IsRUFBRSxFQUFFLFNBQVM7UUFDYixFQUFFLEVBQUUsU0FBUztRQUNiLEVBQUUsRUFBRSxTQUFTO1FBQ2IsRUFBRSxFQUFFLFNBQVM7UUFDYixFQUFFLEVBQUUsU0FBUyxDQUFHLE9BQU87S0FDMUI7SUFFTDs7T0FFRztJQUNILFlBQVksRUFBRSxVQUFVLE1BQU07UUFDMUIsTUFBTSxDQUFDLEVBQUUsQ0FBQyxNQUFNLENBQUMsS0FBSyxDQUFDLEVBQUUsRUFBRSxNQUFNLENBQUMsQ0FBQztJQUN2QyxDQUFDO0lBRUQ7O09BRUc7SUFDSCxRQUFRLEVBQUUsVUFB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S0FBSyxDQUFDLENBQUMsQ0FBQzthQUNSLE1BQU0sQ0FBQyxRQUFRLENBQUMsQ0FBQTtJQUN6QixDQUFDO0NBQ0osQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8vIEZpbGUgbGFzdCBtb2RpZmllZCBvbjogV2VkIERlYyAyMSAyMDE2IDE0OjUzOjM1ICBcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi90eXBpbmdzL3VuZGVyc2NvcmUvdW5kZXJzY29yZS5kLnRzXCIvPjtcbi8vLyA8cmVmZXJlbmNlIHBhdGg9XCIuLi90eXBpbmdzL2QzL2QzLmQudHNcIi8+O1xuXG52YXIgR3JhcGhIZWxwZXJNZXRob2RzOmFueTtcblxuR3JhcGhIZWxwZXJNZXRob2RzID0ge1xuICAgIFxuICAgIG5leHRDb2xvcjogbnVsbCxcbiAgICBsYWJlbHM6IFtdLFxuICAgIHJlbWFrZUdyYXBoQ2FsbHM6IDAsXG4gICAgY29sb3JzOiB7XG4gICAgICAgICAgICAwOiAnIzBFNkZBNCcsICAgLy9kYXJrIHRlYWxcbiAgICAgICAgICAgIDE6ICcjNTFCRkQ4JywgICAvL3RlYWxcbiAgICAgICAgICAgIDI6ICcjMmEyMDU2JywgICAvL25hdnlcbiAgICAgICAgICAgIDM6ICcjRkNBNDU2JywgICAvL2xpZ2h0IG9yYW5nZVxuICAgICAgICAgICAgNDogJyMyYjdiM2QnLCAgIC8vZ3JlZW5cbiAgICAgICAgICAgIDU6ICcjOTdkMzdkJywgICAvL2xpZ2h0IHBhc3RlbCBncmVlblxuICAgICAgICAgICAgNjogJyNDRjUwMzAnLCAgIC8vb3JhbmdlIHJlZFxuICAgICAgICAgICAgNzogJyNGRkI2QzEnLCAgIC8vbGlnaHQgcGlua1xuICAgICAgICAgICAgODogJyM2ZjJmOGMnLCAgIC8vcm95YWwgcHVycGxlXG4gICAgICAgICAgICA5OiAnI2I5N2RkMycsICAgLy9saWdodCBwdXJwbGVcbiAgICAgICAgICAgIDEwOiAnIzdlMDQwNCcsICAvL2J1cmdhbmR5IHJlZFxuICAgICAgICAgICAgMTE6ICcjNzY1NjY3JywgIC8vZ3JleSBwaW5rXG4gICAgICAgICAgICAxMjogJyNGMjc5QkEnLCAgLy9waW5rXG4gICAgICAgICAgICAxMzogJyM5OTNmNmMnLCAgLy9tYXJvb25cbiAgICAgICAgICAgIDE0OiAnIzkxOTE5MScsICAvL2RhcmsgZ3JleVxuICAgICAgICAgICAgMTU6ICcjQkZCRkJEJywgIC8vZ3JleVxuICAgICAgICAgICAgMTY6ICcjZWNkYTNhJywgIC8veWVsbG93XG4gICAgICAgICAgICAxNzogJyNiMmIyMDAnLCAgLy9tdXN0YXJkIHllbGxvd1xuICAgICAgICAgICAgMTg6ICcjMDA2RTdFJywgIC8vZ3JleSBibHVlXG4gICAgICAgICAgICAxOTogJyNiMmYyZmInLCAgLy9saWdodCBibHVlXG4gICAgICAgICAgICAyMDogJyMwNzE1Q0QnLCAgLy9yb3lhbCBibHVlXG4gICAgICAgICAgICAyMTogJyNlOGMyZjMnLCAgLy9saWdodCBsYXZlbmRlclxuICAgICAgICAgICAgMjI6ICcjN2E1MjMwJyAgIC8vYnJvd25cbiAgICAgICAgfSxcblxuICAgIC8qKlxuICAgICAqICBUaGlzIGZ1bmN0aW9uIHRha2VzIGFuIGFycmF5IG9mIGFycmF5cyBvZiBhcnJheXMgYW5kIGZsYXR0ZW5zIGl0IGludG8gb25lIGFycmF5IG9mIGFycmF5cy4gXG4gICAgKiovXG4gICAgY29uY2F0QXNzYXlzOiBmdW5jdGlvbiAoYXNzYXlzKSB7XG4gICAgICAgIHJldHVybiBbXS5jb25jYXQuYXBwbHkoW10sIGFzc2F5cyk7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqICBUaGlzIGZ1bmN0aW9uIHRha2VzIGEgdW5pdCBpZCBhbmQgdW5pdCB0eXBlIGpzb24gYW5kIHJldHVybnMgdGhlIHVuaXQgbmFtZVxuICAgICoqL1xuICAgIHVuaXROYW1lOiBmdW5jdGlvbiAodW5pdElkLCB1bml0VHlwZXMpIHtcbiAgICAgIHJldHVybiB1bml0VHlwZXNbdW5pdElkXS5uYW1lO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiAgVGhpcyBmdW5jdGlvbiB0YWtlcyBhIG1lYXN1cmVtZW50IGlkIGFuZCBtZWFzdXJlbWVudCB0eXBlIGpzb24gYW5kIHJldHVybnMgdGhlXG4gICAgICogIG1lYXN1cmVtZW50IG5hbWVcbiAgICAqKi9cbiAgICBtZWFzdXJlbWVudE5hbWU6IGZ1bmN0aW9uIChtZWFzdXJlbWVudElkLCBtZWFzdXJlbWVudFR5cGVzKSB7XG4gICAgICByZXR1cm4gbWVhc3VyZW1lbnRUeXBlc1ttZWFzdXJlbWVudElkXS5uYW1lO1xuICAgIH0sXG4gICAgXG4gICAgLyoqXG4gICAgICogIFRoaXMgZnVuY3Rpb24gdGFrZXMgYSBzZWxlY3RvciBlbGVtZW50IGFuZCByZXR1cm5zIGFuIHN2ZyBlbGVtZW50IFxuICAgICoqL1xuICAgIGNyZWF0ZVN2ZzogZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgICB2YXIgc3ZnID0gZDMuc2VsZWN0KHNlbGVjdG9yKS5hcHBlbmQoXCJzdmdcIilcbiAgICAgICAgLmF0dHIoXCJwcmVzZXJ2ZUFzcGVjdFJhdGlvXCIsIFwieE1pbllNaW4gbWVldFwiKVxuICAgICAgICAuYXR0cihcInZpZXdCb3hcIiwgXCItNTUgLTMwIDk2MCAzMDBcIilcbiAgICAgICAgLmNsYXNzZWQoXCJzdmctY29udGVudFwiLCB0cnVlKTtcbiAgICAgIFxuICAgICAgcmV0dXJuIHN2ZzsgXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqICBUaGlzIGZ1bmN0aW9uIHRha2VzIGluIEVERGRhdGEsIGEgc2luZ2xlQXNzYXkgbGluZSBlbnRyeSwgYW5kIG1lYXN1cmVtZW50IG5hbWVzIGFuZFxuICAgICAqICB0cmFuc2Zvcm1zIGl0IGludG8gdGhlIGZvbGxvd2luZyBzY2hlbWE6XG4gICAgICogICAgW3tsYWJlbDogXCJkdDkzMDQsIHg6IDEsIHk6IDIuNSwgeF91bml0OiBcIm4vYVwiLCB5X3VuaXQ6IFwiY21vbFwiLCAgbmFtZTogXCJpJ20gYSBwcm90ZWluXG4gICAgICogICAgbmFtZVwifSxcbiAgICAgKiAgICB7bGFiZWw6IFwiZHQzOTAzLCB4OiAxLCB5OiAyMy41LCB4X3VuaXQ6IFwibi9hXCIsIHlfdW5pdDogXCJjbW9sXCIsICBuYW1lOiBcImknbSBhbm90aGVyIHByb3RlaW5cbiAgICAgKiAgICBuYW1lXCJ9XG4gICAgICogICAgLi4uXG4gICAgICogICAgXVxuICAgICoqL1xuICAgIHRyYW5zZm9ybVNpbmdsZUxpbmVJdGVtOiBmdW5jdGlvbiAoZGF0YU9iaikge1xuICAgICAgICAvLyB1bml0IHR5cGVzXG4gICAgICAgIHZhciB1bml0VHlwZXMgPSBkYXRhT2JqWydkYXRhJ10uVW5pdFR5cGVzO1xuICAgICAgICAvLyBtZWFzdXJlbWVudCB0eXBlc1xuICAgICAgICB2YXIgbWVhc3VyZW1lbnRUeXBlcyA9IGRhdGFPYmpbJ2RhdGEnXS5NZWFzdXJlbWVudFR5cGVzO1xuICAgICAgICAvLyBhcnJheSBvZiB4IGFuZCB5IHZhbHVlcyBmb3Igc29ydGluZ1xuICAgICAgICB2YXIgeEFuZFlWYWx1ZXMgPSBbXTtcbiAgICAgICAgLy9kYXRhIGZvciBvbmUgbGluZSBlbnRyeVxuICAgICAgICB2YXIgc2luZ2xlRGF0YVZhbHVlcyA9IGRhdGFPYmpbJ21lYXN1cmUnXS52YWx1ZXM7XG5cbiAgICAgICAgXy5lYWNoKHNpbmdsZURhdGFWYWx1ZXMsIGZ1bmN0aW9uKGRhdGFWYWx1ZSwgaW5kZXgpIHtcbiAgICAgICAgICAgICB2YXIgZGF0YXNldCA9IHt9O1xuICAgICAgICAgICAgLy9jYW4gYWxzbyBjaGFuZ2UgdG8gb21pdCBkYXRhIHBvaW50IHdpdGggbnVsbCB3aGljaCB3YXMgZG9uZSBiZWZvcmUuLlxuICAgICAgICAgICAgaWYgKGRhdGFWYWx1ZVswXS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIGRhdGFWYWx1ZVswXSA9IFtcIjBcIl07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGFWYWx1ZVsxXS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgIGRhdGFWYWx1ZVsxXSA9IFtcIjBcIl07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkYXRhc2V0WydsYWJlbCddID0gJ2R0JyArIGRhdGFPYmpbJ21lYXN1cmUnXS5hc3NheTtcbiAgICAgICAgICAgIGRhdGFzZXRbJ3gnXSA9IHBhcnNlRmxvYXQoZGF0YVZhbHVlWzBdLmpvaW4oKSk7XG4gICAgICAgICAgICBkYXRhc2V0Wyd5J10gPSBwYXJzZUZsb2F0KGRhdGFWYWx1ZVsxXS5qb2luKCkpO1xuICAgICAgICAgICAgZGF0YXNldFsneF91bml0J10gPSBHcmFwaEhlbHBlck1ldGhvZHMudW5pdE5hbWUoZGF0YU9ialsnbWVhc3VyZSddLnhfdW5pdHMsIHVuaXRUeXBlcyk7XG4gICAgICAgICAgICBkYXRhc2V0Wyd5X3VuaXQnXSA9IEdyYXBoSGVscGVyTWV0aG9kcy51bml0TmFtZShkYXRhT2JqWydtZWFzdXJlJ10ueV91bml0cywgdW5pdFR5cGVzKTtcbiAgICAgICAgICAgIGRhdGFzZXRbJ25hbWUnXSA9IGRhdGFPYmpbJ25hbWUnXTtcbiAgICAgICAgICAgIGRhdGFzZXRbJ2NvbG9yJ10gPSBkYXRhT2JqWydjb2xvciddO1xuICAgICAgICAgICAgZGF0YXNldFsnbmFtZWlkJ10gPSBkYXRhT2JqWyduYW1lcyddICsgaW5kZXg7XG4gICAgICAgICAgICBkYXRhc2V0WydsaW5lTmFtZSddID0gZGF0YU9ialsnbGluZU5hbWUnXTtcbiAgICAgICAgICAgIGRhdGFzZXRbJ21lYXN1cmVtZW50J10gPSBHcmFwaEhlbHBlck1ldGhvZHMubWVhc3VyZW1lbnROYW1lKGRhdGFPYmpbJ21lYXN1cmUnXS50eXBlLCBtZWFzdXJlbWVudFR5cGVzKTtcbiAgICAgICAgICAgIGRhdGFzZXRbJ2Z1bGxOYW1lJ10gPSBkYXRhT2JqWydsaW5lTmFtZSddICsgJyAnICsgZGF0YXNldFsnbWVhc3VyZW1lbnQnXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgeEFuZFlWYWx1ZXMucHVzaChkYXRhc2V0KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHhBbmRZVmFsdWVzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgICByZXR1cm4gYS54IC0gYi54O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB4QW5kWVZhbHVlcztcbiAgICB9LFxuXG4gICAgIC8qKlxuICAgICAqIHRoaXMgZnVuY3Rpb24gaXMgdGhlIHNhbWUgYXMgYWJvdmUgYnV0IG1vcmUgc2ltcGxlIGFzIGl0IGlzIGZvciB0aGUgaW1wb3J0IHNlY3Rpb24uXG4gICAgKiovXG4gICAgdHJhbnNmb3JtTmV3TGluZUl0ZW06IGZ1bmN0aW9uIChkYXRhLCBzaW5nbGVEYXRhKSB7XG5cbiAgICAgICAgLy8gYXJyYXkgb2YgeCBhbmQgeSB2YWx1ZXMgZm9yIHNvcnRpblxuICAgICAgICB2YXIgeEFuZFlWYWx1ZXMgPSBbXTtcbiAgICAgICAgLy9kYXRhIGZvciBvbmUgbGluZSBlbnRyeVxuICAgICAgICB2YXIgc2luZ2xlRGF0YVZhbHVlcyA9IHNpbmdsZURhdGEuZGF0YTtcbiAgICAgICAgdmFyIGZ1bGxOYW1lID0gc2luZ2xlRGF0YS5sYWJlbDtcblxuICAgICAgICBfLmVhY2goc2luZ2xlRGF0YVZhbHVlcywgZnVuY3Rpb24oZGF0YVZhbHVlKSB7XG4gICAgICAgICAgICAgdmFyIGRhdGFzZXQgPSB7fTtcbiAgICAgICAgICAgIC8vY2FuIGFsc28gY2hhbmdlIHRvIG9taXQgZGF0YSBwb2ludCB3aXRoIG51bGwgd2hpY2ggd2FzIGRvbmUgYmVmb3JlLi5cbiAgICAgICAgICAgIGlmIChkYXRhVmFsdWVbMF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRhdGFWYWx1ZVswXSA9IFtcIjBcIl07XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGRhdGFWYWx1ZVsxXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGF0YVZhbHVlWzFdID0gW1wiMFwiXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRhdGFzZXRbJ25ld0xpbmUnXSA9IHRydWU7XG4gICAgICAgICAgICBkYXRhc2V0Wyd4J10gPSBkYXRhVmFsdWVbMF07XG4gICAgICAgICAgICBkYXRhc2V0Wyd5J10gPSBwYXJzZUZsb2F0KGRhdGFWYWx1ZVsxXSk7XG4gICAgICAgICAgICBkYXRhc2V0WyduYW1lJ10gPSBzaW5nbGVEYXRhLm5hbWU7XG4gICAgICAgICAgICBkYXRhc2V0WydmdWxsTmFtZSddID0gZnVsbE5hbWU7XG4gICAgICAgICAgICB4QW5kWVZhbHVlcy5wdXNoKGRhdGFzZXQpO1xuICAgICAgICB9KTtcbiAgICAgICAgeEFuZFlWYWx1ZXMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgICAgICAgIHJldHVybiBhLnggLSBiLng7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHhBbmRZVmFsdWVzO1xuICAgIH0sXG4gICAgXG4gICAgLyoqXG4gICAgICogdGhpcyBmdW5jdGlvbiB0YWtlcyBpbiBhIHNpbmdsZSBsaW5lIG5hbWUgYW5kIHN0dWR5J3MgbGluZXMgYW5kIHJldHVybnMgYW4gb2JqZWN0IG9mXG4gICAgICogY29sb3IgdmFsdWVzIHdpdGggbGlkIGtleXNcbiAgICAgKiBsb29zZWx5IGJhc2VkIG9uIGQzIGNhdGVnb3J5MjAgaW4gZm9sbG93aW5nIGxpbms6XG4gICAgICogaHR0cDovL2JsLm9ja3Mub3JnL2FhaXplbWJlcmcvNzhiZDNkYWRlOTU5Mzg5NmE1OWRcbiAgICAqKi9cbiAgICByZW5kZXJDb2xvcjogZnVuY3Rpb24obGluZXMpIHtcblxuICAgICAgICAvL25ldyBjb2xvciBvYmplY3Qgd2l0aCBhc3NheSBpZHMgYW5kIGNvbG9yIGhleFxuICAgICAgICB2YXIgbGluZUNvbG9ycyA9IHt9O1xuICAgICAgICAvL2hvdyBtYW55IGxpbmVzXG4gICAgICAgIHZhciBsaW5lQ291bnQgPSBfLnJhbmdlKE9iamVjdC5rZXlzKGxpbmVzKS5sZW5ndGgpO1xuICAgICAgICAvL3ZhbHVlcyBvZiBsaW5lIG9ialxuICAgICAgICB2YXIgbGluZVZhbHVlcyA9IF8udmFsdWVzKGxpbmVzKTtcbiAgICAgICAgLy9uZXcgb2JqZWN0IHdpdGggbnVtYmVycyBmb3IgaWRzXG4gICAgICAgIHZhciBpbmRleExpbmVzOmFueSA9IHt9O1xuICAgICAgICAvLyBjb2xvciBvYmogdmFsdWVzXG4gICAgICAgIHZhciBjb2xvcktleXMgPSBfLnZhbHVlcyhHcmFwaEhlbHBlck1ldGhvZHMuY29sb3JzKTtcbiAgICAgICAgLy9jcmVhdGUgaW5kZXggb2JqIHdpdGggbnVtYmVycyBmb3IgaWRzIGFuZCBhc3NheSBpZHMgYXMgdmFsdWVzXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZUNvdW50Lmxlbmd0aDsgaSsrICkge1xuICAgICAgICAgICAgaW5kZXhMaW5lc1tpXSA9IGxpbmVWYWx1ZXNbaV0uaWQ7XG4gICAgICAgIH1cbiAgICAgICAgLy9pZiB0aGVyZSBhcmUgbW9yZSB0aGFuIDIyIGxpbmVzLCBjcmVhdGUgYSBiaWdnZXIgY29sb3Igb2JqXG4gICAgICAgIGlmIChsaW5lVmFsdWVzLmxlbmd0aCA+IGNvbG9yS2V5cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHZhciBtdWx0aXBsaWVyID0gTWF0aC5jZWlsKGxpbmVWYWx1ZXMubGVuZ3RoLyBjb2xvcktleXMubGVuZ3RoKSAqIDIyO1xuICAgICAgICAgICAgR3JhcGhIZWxwZXJNZXRob2RzLmNvbG9yTWFrZXIoR3JhcGhIZWxwZXJNZXRob2RzLmNvbG9ycywgY29sb3JLZXlzLCBtdWx0aXBsaWVyKVxuICAgICAgICB9XG4gICAgICAgIC8vY29tYmluZSBhc3NheSBpZHMgYXMga2V5cyB3aXRoIGhleCBjb2xvcnMgYXMgdmFsdWVzXG4gICAgICAgIF8uZWFjaChpbmRleExpbmVzLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICAgICAgICBsaW5lQ29sb3JzW2luZGV4TGluZXNba2V5XV0gPSBHcmFwaEhlbHBlck1ldGhvZHMuY29sb3JzW2tleV07XG4gICAgICAgIH0pO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gbGluZXMpIHsgbGluZXNba2V5XVsnY29sb3InXSA9IGxpbmVDb2xvcnNba2V5XX1cbiAgICAgICAgcmV0dXJuIGxpbmVDb2xvcnNcbiAgICB9LFxuICAgIFxuICAgIC8qKlxuICAgICAqIHRoaXMgZnVuY3Rpb24gdGFrZXMgaW4gdGhlIHNlbGVjdGVkIGNvbG9yIGFuZCByZXR1cm5zIHRoZSBjb2xvciB0aGF0IGNvbWVzIGFmdGVyLiBcbiAgICAqKi9cbiAgICAgY29sb3JRdWV1ZTogZnVuY3Rpb24oc2VsZWN0ZWRDb2xvcikge1xuICAgICAgICB2YXIgcmV2ZXJzZUNvbG9ycyA9IEdyYXBoSGVscGVyTWV0aG9kcy5yZXZlcnNlTWFwKEdyYXBoSGVscGVyTWV0aG9kcy5jb2xvcnMpO1xuICAgICAgICB2YXIgc2VsZWN0ZWRLZXkgPSByZXZlcnNlQ29sb3JzW3NlbGVjdGVkQ29sb3JdO1xuICAgICAgICBpZiAocGFyc2VJbnQoc2VsZWN0ZWRLZXkpID09PSAyMSkge1xuICAgICAgICAgICAgIHNlbGVjdGVkS2V5ID0gLTE7XG4gICAgICAgICB9XG4gICAgICAgIHZhciBuZXh0Q29sb3IgPSBHcmFwaEhlbHBlck1ldGhvZHMuY29sb3JzW3BhcnNlSW50KHNlbGVjdGVkS2V5KSArIDFdO1xuXG4gICAgICAgIEdyYXBoSGVscGVyTWV0aG9kc1snbmV4dENvbG9yJ10gPSBuZXh0Q29sb3I7XG4gICAgfSxcbiAgICBcbiAgICAvKipcbiAgICAgKiB0aGlzIGZ1bmN0aW9uIHRha2VzIGluIGFuIG9iamVjdCBhbmQgdmFsdWUgYW5kIHJldHVybnMgYSBuZXcgb2JqZWN0IHdpdGgga2V5cyBhcyB2YWx1ZXNcbiAgICAgKiBhbmQgdmFsdWVzIGFzIGtleXMuIFxuICAgICoqL1xuICAgIHJldmVyc2VNYXA6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICB2YXIgcmV2ZXJzZU1hcCA9IHt9O1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICAgICAgICBpZiAob2JqLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICByZXZlcnNlTWFwW29ialtrZXldXSA9IGtleTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV2ZXJzZU1hcDtcbiAgICB9LFxuICAgIFxuICAgIC8qKlxuICAgICAqIHRoaXMgZnVuY3Rpb24gdGFrZXMgaW4gdGhlIGNvbG9yIG9iamVjdCwgY29sb3JLZXlzIGFycmF5LCBhbmQgbXVsdGlwbGllciB0byBkZXRlcm1pbmUgaG93XG4gICAgICogbWFueSBuZXcgY29sb3JzIHdlIG5lZWQgYW5kIHJldHVybiBhbmQgYmlnZ2VyIENvbG9yIG9iamVjdFxuICAgICoqL1xuICAgIGNvbG9yTWFrZXI6IGZ1bmN0aW9uKGNvbG9ycywgY29sb3JLZXlzLCBtdWx0aXBsaWVyKSB7XG4gICAgICAgIHZhciBpID0gMjM7XG4gICAgICAgIHZhciBqID0gMDtcbiAgICAgICAgd2hpbGUgKGkgPCBtdWx0aXBsaWVyKSB7XG4gICAgICAgICAgICBjb2xvcnNbaV0gPSBjb2xvcktleXNbal07XG4gICAgICAgICAgICBpZiAoaiA9PT0gMjEpIHtcbiAgICAgICAgICAgICAgICBqID0gLTE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBqKys7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbG9yc1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgb2JqZWN0IHNpemVcbiAgICAqKi9cbiAgICBvYmplY3RTaXplOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgdmFyIHNpemUgPSAwLCBrZXk7XG4gICAgICAgIGZvciAoa2V5IGluIG9iamVjdCkge1xuICAgICAgICAgICAgaWYgKG9iamVjdC5oYXNPd25Qcm9wZXJ0eShrZXkpKSBzaXplKys7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpemU7XG4gICAgfSxcbiAgICBcbiAgICAvKipcbiAgICAgKiAgVGhpcyBmdW5jdGlvbiB0YWtlcyBpbiB0aGUgdW5pdCB0eXBlIGZvciBlYWNoIGFycmF5IGFuZCByZXR1cm5zIHRoZSB0ZXh0IHRvIGRpc3BsYXkgb25cbiAgICAgKiAgdGhlIGF4aXNcbiAgICAqKi9cbiAgICBjcmVhdGVYQXhpczogZnVuY3Rpb24oZ3JhcGhTZXQsIHgsIHN2ZywgdHlwZSkge1xuXG4gICAgICAgIGlmICh0eXBlID09PSAneCcpIHtcbiAgICAgICAgICAgIHR5cGUgPSBcIlRpbWVcIlxuICAgICAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdtZWFzdXJlbWVudCcpIHtcbiAgICAgICAgICAgIHR5cGUgPSBcIk1lYXN1cmVtZW50XCIgXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJuYW1lXCIpIHtcbiAgICAgICAgICAgIHR5cGUgPSBcIkxpbmVcIlxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHlwZSA9ICdIb3VycydcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIHhBeGlzID0gZ3JhcGhTZXQueF9heGlzKHgpO1xuXG4gICAgICAgIGlmIChncmFwaFNldC54X3VuaXQgPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBncmFwaFNldC54X3VuaXQgPSAnbi9hJ1xuICAgICAgICB9XG5cbiAgICAgICAgc3ZnLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ4IGF4aXNcIilcbiAgICAgICAgICAgIC5zdHlsZShcImZvbnQtc2l6ZVwiLFwiMTJweFwiKVxuICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoMCxcIiArIGdyYXBoU2V0LmhlaWdodCArIFwiKVwiKVxuICAgICAgICAgICAgLmNhbGwoeEF4aXMpXG4gICAgICAgICAgICAuYXBwZW5kKCd0ZXh0JylcbiAgICAgICAgICAgIC5hdHRyKFwieVwiLCA0MClcbiAgICAgICAgICAgIC5hdHRyKFwieFwiLCBncmFwaFNldC53aWR0aC8yKVxuICAgICAgICAgICAgLnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIilcbiAgICAgICAgICAgIC50ZXh0KHR5cGUpO1xuICAgICAgICAvL0RyYXcgdGhlIHggR3JpZCBsaW5lc1xuICAgICAgICBzdmcuYXBwZW5kKFwiZ1wiKVxuICAgICAgICAgICAgLmF0dHIoXCJjbGFzc1wiLCBcImdyaWRcIilcbiAgICAgICAgICAgIC5hdHRyKFwidHJhbnNmb3JtXCIsIFwidHJhbnNsYXRlKDAsXCIgKyBncmFwaFNldC5oZWlnaHQgKyBcIilcIilcbiAgICAgICAgICAgIC5jYWxsKHhBeGlzXG4gICAgICAgICAgICAgICAgLnRpY2tTaXplKC1ncmFwaFNldC5oZWlnaHQsIDApXG4gICAgICAgICAgICAgICAgLnRpY2tGb3JtYXQoXCJcIikpO1xuICAgIH0sXG4gICAgXG4gICAgLyoqXG4gICAgICogIFRoaXMgZnVuY3Rpb24gY3JlYXRlcyB0aGUgbGVmdCB5IGF4aXMgc3ZnIG9iamVjdFxuICAgICoqL1xuICAgIGNyZWF0ZUxlZnRZQXhpczogZnVuY3Rpb24oZ3JhcGhTZXQsIGxhYmVsLCB5LCBzdmcpIHtcblxuICAgICAgICB2YXIgeUF4aXMgPSBkMy5zdmcuYXhpcygpLnNjYWxlKHkpXG4gICAgICAgICAgICAgICAgLm9yaWVudChcImxlZnRcIikudGlja3MoNSkudGlja0Zvcm1hdChkMy5mb3JtYXQoXCIuMnNcIikpO1xuXG4gICAgICAgIGlmIChsYWJlbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIGxhYmVsID0gJ24vYSdcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgc3ZnLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJ5IGF4aXNcIilcbiAgICAgICAgICAgIC5zdHlsZShcImZvbnQtc2l6ZVwiLFwiMTJweFwiKVxuICAgICAgICAgICAgLmNhbGwoeUF4aXMpXG4gICAgICAgICAgICAuYXBwZW5kKFwidGV4dFwiKVxuICAgICAgICAgICAgLmF0dHIoJ2NsYXNzJywgJ2F4aXMtdGV4dCcpXG4gICAgICAgICAgICAuYXR0cihcInRyYW5zZm9ybVwiLCBcInJvdGF0ZSgtOTApXCIpXG4gICAgICAgICAgICAuYXR0cihcInlcIiwgLTU1KVxuICAgICAgICAgICAgLmF0dHIoXCJ4XCIsIDAgLSAoZ3JhcGhTZXQuaGVpZ2h0LzIpKVxuICAgICAgICAgICAgLmF0dHIoXCJkeVwiLCBcIjFlbVwiKVxuICAgICAgICAgICAgLnN0eWxlKFwidGV4dC1hbmNob3JcIiwgXCJtaWRkbGVcIilcbiAgICAgICAgICAgIC50ZXh0KGxhYmVsKTtcblxuICAgICAgICAvLyBEcmF3IHRoZSB5IEdyaWQgbGluZXNcbiAgICAgICAgc3ZnLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgIC5hdHRyKFwiY2xhc3NcIiwgXCJncmlkXCIpXG4gICAgICAgICAgICAuY2FsbCh5QXhpc1xuICAgICAgICAgICAgICAgIC50aWNrU2l6ZSgtZ3JhcGhTZXQud2lkdGgsIDApXG4gICAgICAgICAgICAgICAgLnRpY2tGb3JtYXQoXCJcIikpXG5cbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogIFRoaXMgZnVuY3Rpb24gY3JlYXRlcyB0aGUgcmlnaHQgeSBheGlzIHN2ZyBvYmplY3RcbiAgICAqKi9cbiAgICBjcmVhdGVSaWdodFlBeGlzOiBmdW5jdGlvbihsYWJlbCwgeSwgc3ZnLCBzcGFjaW5nKSB7XG4gICAgICAgIFxuICAgICAgICAgICAgdmFyIHlBeGlzID0gZDMuc3ZnLmF4aXMoKS5zY2FsZSh5KVxuICAgICAgICAgICAgICAgIC5vcmllbnQoXCJyaWdodFwiKS50aWNrcyg1KS50aWNrRm9ybWF0KGQzLmZvcm1hdChcIi4yc1wiKSk7XG5cblxuICAgICAgICAgICAgc3ZnLmFwcGVuZChcImdcIilcbiAgICAgICAgICAgICAgICAuYXR0cihcImNsYXNzXCIsIFwieSBheGlzXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJ0cmFuc2xhdGUoXCIgKyBzcGFjaW5nICsgXCIgLDApXCIpXG4gICAgICAgICAgICAgICAgLnN0eWxlKFwiZm9udC1zaXplXCIsXCIxMnB4XCIpXG4gICAgICAgICAgICAgICAgLnN0eWxlKFwiZmlsbFwiLCBcImJsYWNrXCIpXG4gICAgICAgICAgICAgICAgLmNhbGwoeUF4aXMpXG4gICAgICAgICAgICAgICAgLmFwcGVuZCgndGV4dCcpXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJ0cmFuc2Zvcm1cIiwgXCJyb3RhdGUoLTkwKVwiKVxuICAgICAgICAgICAgICAgIC5hdHRyKCdjbGFzcycsICd0ZXh0JylcbiAgICAgICAgICAgICAgICAuYXR0cigneCcsIC0xMTApXG4gICAgICAgICAgICAgICAgLmF0dHIoXCJkeVwiLCBcIi4zMmVtXCIpXG4gICAgICAgICAgICAgICAgLmF0dHIoJ3knLCA0MylcbiAgICAgICAgICAgICAgICAuc3R5bGUoJ3RleHQtYW5jaG9yJywgJ21pZGRsZScpXG4gICAgICAgICAgICAgICAgLnRleHQobGFiZWwpXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqICBUaGlzIGZ1bmN0aW9uIGNyZWF0ZXMgdGhlIHkgYXhpcyB0aWNrIG1hcmtzIGZvciBncmlkXG4gICAgKiovXG4gICAgbWFrZV9yaWdodF95X2F4aXM6IGZ1bmN0aW9uICh5KSB7XG4gICAgICAgIHJldHVybiBkMy5zdmcuYXhpcygpXG4gICAgICAgICAgICAuc2NhbGUoeSlcbiAgICAgICAgICAgIC5vcmllbnQoXCJsZWZ0XCIpXG4gICAgICAgIC8vYWRkIHRpY2tzIGhlcmUhXG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqICBUaGlzIGZ1bmN0aW9uIGNyZWF0ZXMgdGhlIHggYXhpcyB0aWNrIG1hcmtzIGZvciBncmlkXG4gICAgKiovXG4gICAgIG1ha2VfeF9heGlzOiBmdW5jdGlvbih4KSB7XG4gICAgICAgIHJldHVybiBkMy5zdmcuYXhpcygpXG4gICAgICAgICAgICAuc2NhbGUoeClcbiAgICAgICAgICAgIC5vcmllbnQoXCJib3R0b21cIilcbiAgICB9XG59O1xuIl19