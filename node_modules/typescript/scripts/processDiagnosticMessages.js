/// <reference path="../src/compiler/sys.ts" />

function main() {
    if (sys.args.length < 1) {
        sys.write("Usage:" + sys.newLine);
        sys.write("\tnode processDiagnosticMessages.js <diagnostic-json-input-file>" + sys.newLine);
        return;
    }

    var inputFilePath = sys.args[0].replace(/\\/g, "/");
    var inputStr = sys.readFile(inputFilePath);

    var diagnosticMesages = JSON.parse(inputStr);

    var names = Utilities.getObjectKeys(diagnosticMesages);
    var nameMap = buildUniqueNameMap(names);

    var infoFileOutput = buildInfoFileOutput(diagnosticMesages, nameMap);

    // TODO: Fix path joining
    var inputDirectory = inputFilePath.substr(0, inputFilePath.lastIndexOf("/"));
    var fileOutputPath = inputDirectory + "/diagnosticInformationMap.generated.ts";
    sys.writeFile(fileOutputPath, infoFileOutput);
}

function buildUniqueNameMap(names) {
    var nameMap = {};

    var uniqueNames = NameGenerator.ensureUniqueness(names, false, undefined);

    for (var i = 0; i < names.length; i++) {
        nameMap[names[i]] = uniqueNames[i];
    }

    return nameMap;
}

function buildInfoFileOutput(messageTable, nameMap) {
    var result = '// <auto-generated />\r\n' + '/// <reference path="types.ts" />\r\n' + 'module ts {\r\n' + '    export var Diagnostics = {\r\n';
    var names = Utilities.getObjectKeys(messageTable);
    for (var i = 0; i < names.length; i++) {
        var name = names[i];
        var diagnosticDetails = messageTable[name];

        result += '        ' + convertPropertyName(nameMap[name]) + ': { code: ' + diagnosticDetails.code + ', category: DiagnosticCategory.' + diagnosticDetails.category + ', key: "' + name.replace('"', '\\"') + '" },\r\n';
    }

    result += '    };\r\n}';

    return result;
}

function convertPropertyName(origName) {
    var result = origName.split("").map(function (char) {
        if (char === '*') {
            return "_Asterisk";
        }
        if (char === '/') {
            return "_Slash";
        }
        if (char === ':') {
            return "_Colon";
        }
        return /\w/.test(char) ? char : "_";
    }).join("");

    // get rid of all multi-underscores
    result = result.replace(/_+/g, "_");

    // remove any leading underscore, unless it is followed by a number.
    result = result.replace(/^_([^\d])/, "$1");

    // get rid of all trailing underscores.
    result = result.replace(/_$/, "");

    return result;
}

var NameGenerator;
(function (NameGenerator) {
    function ensureUniqueness(names, isCaseSensitive, isFixed) {
        if (!isFixed) {
            isFixed = names.map(function () {
                return false;
            });
        }

        var names = names.slice();
        ensureUniquenessInPlace(names, isCaseSensitive, isFixed);
        return names;
    }
    NameGenerator.ensureUniqueness = ensureUniqueness;

    function ensureUniquenessInPlace(names, isCaseSensitive, isFixed) {
        for (var i = 0; i < names.length; i++) {
            var name = names[i];
            var collisionIndices = Utilities.collectMatchingIndices(name, names, isCaseSensitive);

            // We will always have one "collision" because getCollisionIndices returns the index of name itself as well;
            // so if we only have one collision, then there are no issues.
            if (collisionIndices.length < 2) {
                continue;
            }

            handleCollisions(name, names, isFixed, collisionIndices, isCaseSensitive);
        }
    }

    function handleCollisions(name, proposedNames, isFixed, collisionIndices, isCaseSensitive) {
        var suffix = 1;

        for (var i = 0; i < collisionIndices.length; i++) {
            var collisionIndex = collisionIndices[i];

            if (isFixed[collisionIndex]) {
                continue;
            }

            while (true) {
                var newName = name + suffix;
                suffix++;

                // Check if we've synthesized a unique name, and if so
                // replace the conflicting name with the new one.
                if (!proposedNames.some(function (name) {
                    return Utilities.stringEquals(name, newName, isCaseSensitive);
                })) {
                    proposedNames[collisionIndex] = newName;
                    break;
                }
            }
        }
    }
})(NameGenerator || (NameGenerator = {}));

var Utilities;
(function (Utilities) {
    /// Return a list of all indices where a string occurs.
    function collectMatchingIndices(name, proposedNames, isCaseSensitive) {
        var matchingIndices = [];

        for (var i = 0; i < proposedNames.length; i++) {
            if (stringEquals(name, proposedNames[i], isCaseSensitive)) {
                matchingIndices.push(i);
            }
        }

        return matchingIndices;
    }
    Utilities.collectMatchingIndices = collectMatchingIndices;

    function stringEquals(s1, s2, caseSensitive) {
        if (caseSensitive) {
            s1 = s1.toLowerCase();
            s2 = s2.toLowerCase();
        }

        return s1 == s2;
    }
    Utilities.stringEquals = stringEquals;

    // Like Object.keys
    function getObjectKeys(obj) {
        var result = [];

        for (var name in obj) {
            if (obj.hasOwnProperty(name)) {
                result.push(name);
            }
        }

        return result;
    }
    Utilities.getObjectKeys = getObjectKeys;
})(Utilities || (Utilities = {}));

main();
//# sourceMappingURL=processDiagnosticMessages.js.map
