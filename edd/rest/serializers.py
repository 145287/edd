"""
Defines serializers for EDD's nascent REST API, as supported by the django rest framework
(http://www.django-rest-framework.org/)
"""

from django.contrib.auth import get_user_model
from main.models import Line, MetadataType, MetadataGroup, Strain, Study, Update, Protocol, \
    MeasurementUnit
from rest_framework import reverse, serializers


####################################################################################################
# unused
####################################################################################################
class UpdateSerializer(serializers.ModelSerializer):
    class Meta:
        model = Update
        fields = ('mod_time', 'mod_by', 'path', 'origin')
        depth = 0

####################################################################################################


class StudySerializer(serializers.ModelSerializer):
    class Meta:
        model = Study
        fields = ('pk', 'name', 'uuid', 'slug', 'description', 'created', 'updated', 'contact',
                  'contact_extra',
                  'metabolic_map', 'meta_store')
        # here after
        # confirming that Lines (our primary concern at the moment) work
        depth = 0
        lookup_field = 'study'


# TODO: unused initial attempt to follow nested resource guidance in Django REST Frameworks' docs
# Either complete / use, or remove. See
# http://www.django-rest-framework.org/api-guide/relations/#custom-hyperlinked-fields
class StudyLineRelatedField(serializers.HyperlinkedRelatedField):
    """A custom HyperLinkedRelatedField to allow study-related Lines to be accessed from
    /rest/study/<study_pk>/lines/<line_pk>/. HyperLinkedRelatedFields, including those generated by
    the much simpler ModelSerializer implementation, only allows for a single primary key to be
    present in the URL, as evinced by server-side error messages like "TypeError: put() got an
    unexpected keyword argument 'study'"
    """

    # view_name='StudyLine'
    view_name = 'StudyListLinesView-list'
    lookup_field = 'study'

    def get_url(self, line, view_name, request, format):
        url_kwargs = {
            'study': line.study_id,
            'line': line.object_ref_id,
        }
        return reverse(view_name, kwargs=url_kwargs, request=request, format=format)

    def get_object(self, view_name, view_args, view_kwargs):
        lookup_kwargs = {
            'study': view_kwargs['study'],
            'line': view_kwargs['line']
        }
        return self.get_queryset().get(**lookup_kwargs)

    def get_queryset(self):
        return Line.objects.get(pk=self.kwargs['study'], study__pk=self.kwargs['study'])


class LineSerializer(serializers.ModelSerializer):
    class Meta:
        model = Line
        # Note: display only a subset of the fields
        # TODO: follow up on contact extra field -- can't be null/blank, but appears unused in GUI
        fields = ('pk', 'study', 'name', 'description', 'control', 'replicate', 'contact',
                  'experimenter', 'protocols', 'strains', 'meta_store')

        # study = StudyLineRelatedField(many=False, read_only=True)
        # contact = serializers.StringRelatedField(many=False)
        carbon_source = serializers.StringRelatedField(many=False)
        # strains = serializers.StringRelatedField(many=True, read_only=True)
        depth = 0

        def create(self, validated_data):
            """
            Create and return a new Line instance, given the validated data
            """
            return Line.objects.create(**validated_data)

        def update(self, validated_data):
            """
            Update and return an existing Line instance, given the validated new values
            """


class UserSerializer(serializers.HyperlinkedModelSerializer):
    class Meta:
        model = get_user_model()
        depth = 0


class MetadataTypeSerializer(serializers.ModelSerializer):
    class Meta:
        model = MetadataType
        depth = 0
        fields = ('pk', 'type_name', 'type_i18n', 'input_size', 'input_type', 'default_value',
                  'prefix', 'postfix', 'for_context', 'type_class', 'group')


class MeasurementUnitSerializer(serializers.ModelSerializer):
    class Meta:
        model = MeasurementUnit
        depth = 0
        fields = ('pk', 'unit_name', 'display', 'alternate_names', 'type_group')


class ProtocolSerializer(serializers.ModelSerializer):
    class Meta:
        model = Protocol
        depth = 0
        fields = ('pk', 'uuid', 'name', 'description', 'owned_by', 'variant_of', 'default_units',
                  'categorization')


class MetadataGroupSerializer(serializers.ModelSerializer):
    class Meta:
        model = MetadataGroup
        depth = 0


class StrainSerializer(serializers.ModelSerializer):

    class Meta:
        model = Strain

        fields = ('name', 'description', 'registry_url', 'registry_id', 'pk')
        depth = 0

    # def __init__(self, instance=None, data=empty, **kwargs):
    #      super(StrainSerializer, self).__init__(instance, data, **kwargs)

    # work around an apparent oversite in ModelSerializer's __new__ implementation that prevents us
    # from using it to construct new objects from a class instance with kw arguments similar to its
    # __init__() method
    # @staticmethod
    # def __new__(cls, *args, **kwargs):
    #     kwargs.pop('data', empty)
    #     kwargs.pop('instance', None)
    #     return serializers.ModelSerializer.__new__(cls, *args, **kwargs)
