# -*- coding: utf-8 -*-
# Generated by Django 1.9.11 on 2017-02-02 04:15
from __future__ import unicode_literals

import json
import os
import re

from collections import defaultdict
from django.db import migrations, models


carbon_pattern = re.compile(r'C(\d*)')
datasource = None


def update_metabolites(apps, schema_editor):
    """
    """
    metabolites = _load_metabolite_json()
    bigg_to_metabolite = defaultdict(list)
    name_to_metabolite = defaultdict(list)
    lower_to_metabolite = defaultdict(list)
    for m in metabolites.itervalues():
        # some metabolites have multiple bigg IDs
        for bigg in m["identifierLinks"]["universal_bigg_id"]:
            bigg_to_metabolite[bigg].append(m)
        # map name and synonyms
        name_to_metabolite[m["name"]].append(m)
        lower_to_metabolite[m["name"].lower()].append(m)
        for synonym in m["synonyms"]:
            name_to_metabolite[synonym].append(m)
            lower_to_metabolite[synonym.lower()].append(m)
    Datasource = apps.get_model('main', 'Datasource')
    Metabolite = apps.get_model('main', 'Metabolite')
    # create Datasource to mark all metabolites
    global datasource
    datasource = Datasource(
        name='BIGG and PubChem via TBackman',
        url='https://repo.jbei.org/users/tbackman/repos/edd-metabolites/browse/?at=a408f643011bb2ee32694861bf15a0e0e61ba76c',
        created=_create_update(apps),
    )
    datasource.save()
    # loop over all metabolites, and also check how many measurements are using it
    for m in Metabolite.objects.annotate(measure_count=models.Count('measurement')):
        if m.short_name in bigg_to_metabolite:
            _merge_metabolite(m, bigg_to_metabolite[m.short_name])
        elif m.type_name in name_to_metabolite:
            _merge_metabolite(m, name_to_metabolite[m.type_name])
        elif m.short_name in name_to_metabolite:
            _merge_metabolite(m, name_to_metabolite[m.short_name])
        elif m.type_name.lower() in lower_to_metabolite:
            _merge_metabolite(m, lower_to_metabolite[m.type_name.lower()])
        elif m.measure_count == 0:
            # no match found in merged BIGG/PubChem dataset, and no measurements: delete
            m.delete()
        else:
            # no match found in merged BIGG/PubChem dataset: mark for validation
            m.tags.append('needs-validation')
            m.save(update_fields=['tags'])


def _count_carbons(formula):
    for match in carbon_pattern.finditer(formula):
        amount = match.group(1)
        yield int(amount) if amount else 1


def _create_update(apps):
    from main.models import Update
    MigrateUpdate = apps.get_model('main', 'Update')
    app_update = Update.load_update(path=__name__)
    return MigrateUpdate.objects.get(pk=app_update.pk)


def _id_links_generator(update_list):
    for info in update_list:
        for src, ids in info['identifierLinks'].iteritems():
            # skip universal_bigg_id
            if src != 'universal_bigg_id':
                for identifier in ids:
                    yield '%s:%s' % (src, identifier)


def _load_metabolite_json():
    metabolite_file = os.path.join(os.path.dirname(__file__), 'eddMetabolites.json')
    with open(metabolite_file, 'r') as f:
        return json.load(f)


def _merge_metabolite(metabolite, update_list, second_pass=False):
    # sanity check values
    mass = {info['mass'] for info in update_list}
    formula = {info['formula'] for info in update_list}
    smiles = {info['canonicalSMILES'] for info in update_list}
    if len(mass) == 1 and len(formula) == 1 and len(smiles) == 1:
        # collect names
        names = {name for name in _names_generator(update_list)}
        metabolite.alt_names = list(names)
        # collect identifierLinks
        links = {link for link in _id_links_generator(update_list)}
        metabolite.id_map = list(links)
        # set values
        metabolite.molar_mass = mass.pop()
        metabolite.molecular_formula = formula.pop()
        metabolite.smiles = smiles.pop()
        metabolite.carbon_count = sum(_count_carbons(metabolite.molecular_formula))
        # set Datasource
        metabolite.type_source = datasource
        # save updated metabolite
        metabolite.save()
    elif not second_pass:
        # have multipe ions, pick the ones without +- in formula
        shortlist = [
            info
            for info in update_list
            if '+' not in info["formula"] and '-' not in info["formula"]
        ]
        _merge_metabolite(metabolite, shortlist, second_pass=True)
    elif metabolite.measure_count == 0:
        # no match found in merged BIGG/PubChem dataset, and no measurements: delete
        metabolite.delete()
    elif len(update_list) > 1:
        # mark these for verification, in case heuristics are wrong
        metabolite.tags.append('needs-verification') 
        # choose the lowest PubChem cid
        _merge_metabolite(
            metabolite,
            [min(update_list, key=lambda m: int(m['pubChemCid']))],
            second_pass=True
        )
    else:
        # no match found in merged BIGG/PubChem dataset: mark for validation
        metabolite.tags.append('needs-validation')
        metabolite.save(update_fields=['tags'])


def _names_generator(update_list):
    for info in update_list:
        yield info['name']
        yield info['IUPACName']
        for synonym in info['synonyms']:
            yield synonym


class Migration(migrations.Migration):

    dependencies = [
        ('main', '0003_metabolite_pubchem'),
    ]

    operations = [
        migrations.RunPython(code=update_metabolites, reverse_code=migrations.RunPython.noop),
    ]
